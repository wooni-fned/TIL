# 배열

- 같은 종류의 메모리를 쉽게 만드는 방법
- 문법

```java
       메모리종류[] 메모리이름 = new 메모리종류[개수]
       데이터타입[] 변수명 = new 데이터타입[개수];
       ex) int[] arr = new int[5];
```

- C언어 스타일

```c#
       데이터타입 변수명[] = new 데이터타입[개수];
       ex) int arr[] = new int[5];
```

- 배열의 개수는 int 타입의 최대 값과 같다.
- 즉 2147483647 개 이다. 
- 배열의 최대 크기 = Integer.MAX_VALUE - 2
- `int[] arr3 = new int[2147483647];` // 실행 오류 => VM의 배열 크기 제한을 초과
- 해결책?
  - JVM을 실행할 때 최대 힙(heap) 메모리의 크기를 늘리면 된다.
  - JVM 실행 옵션에 다음을 추가하라!
    - Xmx메모리크기
    - `$ java -Xmx20000m ...`
- `int[] arr3 = new int[2147483645];` // OK!
- `int[] arr3 = new int[Integer.MAX_VALUE - 2];` // OK!
- hash주소값으로 출력됨 `[I@ 7ad041f3`

----

## 배열 메모리에 접근방법

- 문법

```java
         배열변수[인덱스] = 값;
         ex) arr1[0] = 100;
```

- 배열의 인덱스는 0부터 시작한다.
- 인덱스의 범위는 0 ~ (배열개수 - 1) 이다.

----

## 배열 레퍼런스와 배열 인스턴스

- 래퍼런스 = 매개변수[참조형(referance매개변수]
  - 주소값을 읽고,수정 이 가능하다.
  - 값이 아닌 메모리의 주소를 담는 변수.
- 인스턴스
  - 값을 저장하는 메모리.

```java
public class Example {
  public static void main(String[] args) {

    int[] arr1 = new int[5];
    
    // 배열 선언문 분석:
    // arr1
    //   - 배열 메모리의 주소를 담는 변수이다.
    //   - 이렇게 메모리의 주소를 보관하는 변수를 '레퍼런스[참조형 매개변수]'라 부른다.
    
    // new int[5]
    //   - new 명령은 사용할 메모리를 확보하는 명령이다.
    //   - 즉 연속된 5 개의 int 타입 메모리를 준비하라는 명령이다.
    //   - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴한다.
    //   - 이렇게 값을 저장하기 위해 확보된 메모리를 "인스턴스"라 부른다.
    
    // new 명령은 메모리를 확보하는 명령이다.
    // - 리턴 값은 확보된 메모리의 시작 주소이다.

    arr1 = new int[5];

    arr1[0] = 100; // arr1에 저장된 주소로 찾아가서 0번째 항목에 값을 넣어라!
    arr1[1] = 200; // arr1에 저장된 추소로 찾아가서 1번째 항목에 값을 넣어라!

    System.out.println(arr1[0]);
    System.out.println(arr1[1]);
  }
}
```

----

## 배열 메모리 초기화

- 배열 선언 + 초기화
  - 데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
  - 배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
  - 배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
  - 즉 다음은 값 개수만큼 int 메모리가 3개가 생성된다.
    - ex) int[] arr = new int[]{10, 20, 30};
  - 다음과 같이 new 명령을 생략할 수 있다.
    - 데이터타입[] 변수명 = {값, 값, 값};
    - ex) int[] arr = {10, 20, 30};

- 배열 선언 후 따로 배열 초기화 문장 실행
  - 데이터타입[] 변수명;
  - 변수명 = new 데이터타입[]{값, 값, 값};
  
```java
  ex) 
  int[] arr1;
  arr1 = new int[]{10, 20, 30}; 
```

  - 변수를 선언한 후 따로 배열을 초기화시킬 때는 new 명령을 생략할 수 없다.

----

## 가비지(garbage)

- 주소를 잃어 버려 사용할 수 없는 메모리
- 특정 조건이 되면 가비지 수집기(garbage collector)에 의해 메모리 해제된다.
 메모리 해제? 다른 용도로 사용할 수 있도록 표시한다는 의미다.

### 가비지 수집 조건 = 가비지 컬렉터가 동작할 때

- 메모리가 부족할 때
  - 운영체제로부터 메모리를 추가로 받기 전에 먼저 기존에 사용하던 메모리에서 가비지를 제거한다.
- CPU가 한가할 때
  - 24시간 365일 내내 실행하는 서버 프로그램인 경우, 실행 중간에 CPU가 한가할 때 가비지를 제거한다.
- 주의!
  - 프로그램(JVM)을 종료하면 JVM 사용한 메모리를 운영체제가 모두 회수한다.

### 가바지는 누가 언제 해제시키는가?

- jvm의 보조프로세스(스레드)인 "가비지 컬렉터"가 해제시킨다

### 가비지를 강제로 지우도록 명령하는 방법?

- 자바는 없다!
- C 언어 => free(메모리주소);
- C++ 언어 => delete 객체주소;
- 요즘 언어의 트랜드는 사용하지 않는 메모리를 개발자가 직접 해제하는 것이 아니라 VM이 해제하는 것이다.
  - 예) JavaScript, C#, Python, PHP, Go, Java 등
- 요즘 언어의 트랜드는 VM으로 실행하는 것이다.
  - 왜? 직접 기계어로 전환되면 메모리를 관리를 자동으로 수행할 수 없다.

### 가비지 컬렉터를 강제로 실행하는 방법?

- 없다!
- 단 원래 계획보다 가능한 빨리 실행하라고 독촉하는 방법은 있다. `System.gc()` 메서드 호출
- 그런데 바로 실행할 지 나중에 실행할 지 그 시점을 보장하지는 않는다.

### 간단예제

```java

  public static void main(String[] args) {

    int[] arr1;
    arr1 = new int[5];
    arr1[0] = 100;
    arr1 = new int[] { 200, 200, 200 };
        System.out.println(arr1[0]);
  }

```