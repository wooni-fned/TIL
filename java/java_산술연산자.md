# 연산자

## 산술연산자

- 기본 연산단위
  - `*`, `/`, `%` 는 `+`, `-` 보다 먼저 계산된다.
- 자바는 정수 변수에 대해 산술 연산을 수행할 때, 변수값이 4바이트 보다 작다면
  임시 4바이트 메모리를 만들어 연산을 수행한다.
- 연산 결과도 당연히 4바이트가 된다.
- boolean 타입에 대해서는 산술 연산자를 사용할 수 없다.
- `+` 연산자는 문자열 연결 용도로 사용된다.
- 자바의 최소 연산 단위는 int이다.
- 따라서 int 보다 작은 크기의 메모리 값을 다룰 때는 내부적으로 int로 자동형변환을 
  수행한 다음에 연산을 수행한다.
- 내부적으로 자동 형변환하는 것을 `"암시적 형변환(implicit type conversion)"`이라 부른다.
  - byte + byte = int
  - short + short = int
  - byte + short = int
- 연산 결과는 항상 피연산자의 타입과 같다.
  - int + int = int
  - long + long = long
  - float + float = float
  - double + double = double
- 다른 타입과 연산을 수행할 때는 내부적으로 같은 타입으로 맞춘 다음에 실행한다.

```java
int i = 5;
int j = 2;
float r = i / j; // int와 int의 연산 결과는 항상 int이다.

r = (float)i / (float)j; // float / float = float
// i / j의 값은 2.5가 되고
// r에 저장되는 것은 2.5이다.

// 물론 두 개의 정수 값 중 한 개만 float으로 형변환해도 된다.
// => 연산을 수행할 때 나머지 변수가 암시적 형변환이 이루어지기 때문이다.
r = i / (float)j;
```

### 산술연산 결과타입 예제

1. 계산값이 클때

```java
int x = Integer.MAX_VALUE; // 0x7fffffff = 약 +21억
int y = Integer.MAX_VALUE; // 0x7fffffff = 약 +21억

int r1 = x + y; // 0x7fffffff + 0x7fffffff = 0xfffffffe = -2
//   0111 1111 1111 1111 1111 1111 1111 1111(x)
// + 0111 1111 1111 1111 1111 1111 1111 1111(y)
// ---------------------------------------------
//   1111 1111 1111 1111 1111 1111 1111 1110(r1)
// => int와 int의 연산 결과가 int의 범위를 넘어가면 
//    의도한 결과가 나오지 않을 수 있다.

// 그래서 int와 int의 연산 결과를 더 큰 메모리에 담는다면 해결될까?
long r2 = x + y;  // 0x7fffffff + 0x7fffffff = 0xfffffffe = -2
// 해결 안됨!
// r2의 출력 결과를 보면 42억이 출력되는 것이 아니라 -2가 출력된다.
// 이유?
// - int 와 int의 연산 결과는 피연산자와 같은 4바이트 int가 된다.
// - 그래서 8바이트 long 변수에 저장하기 전에 
// - 이미 그 결과는 int 값으로 -2가 되기 때문에 
// - long 변수의 값이 -2가 된다.

// 진정한 해결책?
// - int와 int 연산 결과가 int 크기를 넘어갈 것 같으면 형변환하여 계산
r2 = (long)x + (long)y;
```

2. 소수점 계산

```java
float f1 = 987.6543f;
float f2 = 1.111111f;
float r1 = f1 + f2;

/*
f1과 f2에 들어 있는 값이 유효자릿수라 하더라도
연산 결과가 유효자릿수가 아니라면 값이 잘리거나 반올림 된다.
=> float과 float의 연산 결과는 float이기 때문이다.
     987.6543
   +   1.111111
  ---------------
     988.765411  <=== float의 유효자릿수인 7자리를 넘어간다.
     988.7654    <=== 유효자릿수를 넘어가는 수는 짤린다.

기대값: 987.6543 + 1.111111 = 988.765411
결과값: 988.7654
결과가 옳지 않게 나온 이유?
=> float과 float의 연산 결과는 float이다.
=> 그래서 메모리 크기를 넘어가는 뒤의 11은 짤린다.
*/

// 그럼 결과를 담을 변수의 크기를 늘리면 되는가?
double r2 = f1 + f2;
/*
기대값: 988.765411
결과값: 988.765380859375
기대한 결과가 나오지 않은 이유?
=> float과 float의 연산 결과는 float이다.
=> double 변수에 저장하기 전에 이미 float 값이 되면서 일부 값이 왜곡되었다.

그런데 r1 변수와 달리 뒤에 이상한 숫자가 많이 붙는 이유는 무엇인가?
=> IEEE 754의 이진수 변환 문제때문이다.
=> 4바이트 float 부동소수점을 8바이트 double 부동소수점 변수에 저장할 때 
   왜곡된 값이 들어 갈 수 있다.
=> float을 double 변수에 넣을 때 왜곡이 발생하기 때문에 
   가능한 double 변수로 값을 바꾼 다음에 연산을 수행
   더 좋은 것은 처음부터 double 변수를 사용
*/

// 다음과 같이 처음부터 double 변수를 사용
double d1 = 987.6543;
double d2 = 1.111111;
double r5 = d1 + d2; // = 988.765411
// 그럼에도 실제 출력해보면 맨 뒤에 극한의 작은 수가 붙는다.
// 이유? IEEE 754 이진수 변환 문제이다. 고민하지 말라!
// 어떻게 처리할 건데? 맨 뒤에 붙은 극한의 작은 수는 그냥 잘라 버린다.
```

-----

## 관계연산자 (relational operators: <, <=, >, >=), 등위 연산자(equality operators: ==, !=)

간단예제
```java
double d1 = 987.6543;
double d2 = 1.111111;
System.out.println((d1 + d2) == 988.765411);
// 결과는 false이다.
// 이유?
// - 부동소수점 값을 IEEE 754 명세에 따라 2진수로 바꿔 메모리에 담을 때
//   정규화(소수점 이하의 수를 2진수로 바꾸는) 과정에서 정수로 딱 떨어지지 않는 경우가 있다.
//   즉 극한의 미세 소수점이 붙을 수 있다. 
// - CPU나 OS, JVM의 문제가 아니다.
// - IEEE 754 명세에 따라 부동소수점을 처리하는 모든컴퓨터에서 발생하는 문제이다.
// - 이런 부동소수점을 계산할 때 기대하는 값과 다른 값이 나올 수 있다.
// - 또한 연산한 결과를 메모리에 담을 때도 정규화 과정에서 극한의 미세 소수점이 붙을 수 있다.

// IEEE 754의 변환 공식에 따라 발생되는 이런 문제를 
// 실무 프로그래밍 할 때 해결하는 방법?

System.out.println((d1 + d2) == (x + y)); // false
// 소수점 뒤에 붙은 극소수의 값을 무시하면 된다.
// => JVM이 자동으로 처리하지 않는다.
// => 다음과 같이 개발자가 직접 처리해야 한다.
double EPSILON = 0.00001;
System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON);
```

-----

## 논리연산자 (&&, ||, !(not), ^(XOR; exclusive-OR))

- AND 연산자 `(&&)`
  - 두 개의 논리 값이 모두 true일 때 결과가 true가 된다.
- OR 연산자 `(||)`
  - 두 개의 논리 값 중 한 개라도 true이면 결과는 true가 된다.
- NOT 연산자 `!(not)`
  - true는 false로 false는 true로 바꾼다.
- exclusive-OR(XOR)연산자 `^(XOR)`
  - 배타적 비교 연산자라 부른다.
  - 두 개의 값이 다를 때 true이다.
  - ^ 연산자를 정수 값에 대해 사용하면
  - 논리 연산자가 아니라 비트 연산자로 동작한다.
  - 비트 연산자인 ^ 은 비트 단위로 연산을 수행한다.
- boolean 타입이 아닌 데이터 타입에 대해서는 사용할 수 없다.

-----

## 비트연산자 (&, |, ^, ~)

- 정수 값에 대해서는 &&와 ||, !을 사용할 수 없다.
- 그러나 &, |, ^, ~는 사용할 수 있다.
- 각 비트 단위로 연산을 수행한다.
- 1은 true, 0은 false라고 간주하고 계산한다.
- 출력 결과도 정수이다.

간단 예제를 통해 알아보자

```java
int a = 0b0110_1100;
int b = 0b0101_0101;
System.out.println(a & b);
// a = 0000 0000 0000 0000 0000 0000 0110 1100
// b = 0000 0000 0000 0000 0000 0000 0101 0101
// --------------------------------------------
// 0000 0000 0000 0000 0000 0000 0100 0100 = 68

System.out.println(a | b);
// a = 0000 0000 0000 0000 0000 0000 0110 1100
// b = 0000 0000 0000 0000 0000 0000 0101 0101
// --------------------------------------------
// 0000 0000 0000 0000 0000 0000 0111 1101 = 125

System.out.println(a ^ b);
// a = 0000 0000 0000 0000 0000 0000 0110 1100
// b = 0000 0000 0000 0000 0000 0000 0101 0101
// --------------------------------------------
// 0000 0000 0000 0000 0000 0000 0011 1001 = 57

// 비트 연산에서 not은 ! 연산자가 아니라 ~ 연산자 이다.
System.out.println(~a);
// a = 0000 0000 0000 0000 0000 0000 0110 1100
// --------------------------------------------
// 1111 1111 1111 1111 1111 1111 1001 0011 = -109
```

### && or &

- `&&`, `||`
  - 앞의 피연산자의 값으로 결과를 알 수 있다면 뒤의 명령은 실행하지 않는다.
- `&`, `|`
  - 앞의 피연산자로 결과를 알 수 있을 지라도, 뒤에 놓은 명령까지 모두 실행한다.

-----

## 비트 이동 연산자 : >>, >>>, <<

### `<<` 비트이동 연산자

- 왼쪽으로 비트를 이동시킨다.
- 오른 쪽 빈자리는 `0`으로 채운다.
- 왼쪽 경계를 넘어간 비트는 자른다.
- 음수의 경우는 양수로 바뀔 수 있다.

```java
i = 11; // [00000000000000000000000000001011]
System.out.println(i << 1); //   0[00000000000000000000000000010110] => 22
System.out.println(i << 2); //  00[00000000000000000000000000101100] => 44
System.out.println(i << 3); // 000[00000000000000000000000001011000] => 88

int a = -0x7f_ff_ff_fa; // -21_4748_3642
System.out.println(a);      //     [10000000000000000000000000000110]
System.out.println(a << 1); //    1[00000000000000000000000000001100] = 12
System.out.println(a << 2); //   10[00000000000000000000000000011000] = 24
System.out.println(a << 3); //  100[00000000000000000000000000110000] = 48
```

- 왼쪽 이동
  - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
  - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다 왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
    이 비트 이동 연산을 자주 사용한다.
  - 비트 이동 => '2^n 이동비트'를 곱한 것과 같은 결과를 만든다.

-----

### `>>` 비트이동 연산자

- 오른쪽 이동
  - 왼쪽 쪽 빈자리를 원래 숫자와 같은 부호 값으로 채운다.
  - 양수라면 0, 음수라면 1을 채운다.
  - 오른쪽 경계를 넘어간 비트는 자른다.
- 음수 값에 대해 오른쪽으로 비트 이동
  - 2^-n으로 나눈 것과 같다.
  - 소수점이 있을 경우 그 수 보다 바로 밑 정수 값이 결과이다.
  - 왼쪽 빈자리가 부호비트로 채워진다.

```java
int i = 105; // [00000000000000000000000001101001]

System.out.println(i); //                   => 105

System.out.println(i >> 1);
// [ 0000000000000000000000000110100]1
// [00000000000000000000000000110100]       => 52

System.out.println(i >> 2);
// [  000000000000000000000000011010]01
// [00000000000000000000000000011010]       => 26

System.out.println(i >> 3);
// [   00000000000000000000000001101]001
// [00000000000000000000000000001101]       => 13

System.out.println(i >> 4);
// [    0000000000000000000000000110]1001
// [00000000000000000000000000000110]       => 6

int i = -87; // [11111111111111111111111110101001]

System.out.println(i); //                   => -87

System.out.println(i >> 1);
// [ 1111111111111111111111111010100]1
// [11111111111111111111111111010100]1      => -44

System.out.println(i >> 2);
// [  111111111111111111111111101010]01
// [11111111111111111111111111101010]01     => -22

System.out.println(i >> 3);
// [   11111111111111111111111110101]001
// [11111111111111111111111111110101]001    => -11

System.out.println(i >> 4);
// [    1111111111111111111111111010]1001
// [11111111111111111111111111111010]1001    => -6
```

- 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
- 예) n에 대해 x비트를 오른쪽으로 이동 = n / 2**x
- 소수점이 있는 경우 그 수 보다 작은 바로 밑 정수 값이 된다.
- 나누기 연산을 수행하는 것 보다 계산 속도가 빠르다.
- 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에 소수점 이하까지 정확하게 계산할 것이
   아니라면 오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.

-----

### `>>>` 비트이동 연산자

- 오른쪽으로 비트를 이동시킨다.
- 왼쪽 빈자리를 음수 양수 상관없이 무조건 0으로 채운다.
- 오른쪽 경계를 넘어간 비트는 자른다.

```java
int i = -87; // [11111111111111111111111110101001]

System.out.println(i);

System.out.println(i >>> 1);
// [ 1111111111111111111111111010100]1
// [01111111111111111111111111010100]1      => 2147483604

System.out.println(i >>> 2);
// [  111111111111111111111111101010]01
// [00111111111111111111111111101010]01     => 1073741802

System.out.println(i >>> 3);
// [   11111111111111111111111110101]001
// [00011111111111111111111111110101]001     => 536870901

System.out.println(i >>> 4);
// [    1111111111111111111111111010]1001
// [00001111111111111111111111111010]1001     => 268435450
```

-----

## 조건연산자 `? :`

- `조건 ? 표현식1 : 표현식2`
  - 조건이 참이면 표현식1을 실행하고, 조건이 거짓이면 표현식2를 실행한다.
- 조건연산자의 왼쪽은 변수이어야 한다.
- 표현식(expression)?
  - 작업을 수행한 후 결과를 리턴하는 문장이다.
- 문장(statement)?
  - 작업을 수행시키는 명령이다.
- 문장과 표현식의 관계
  - statement 중에서 결과를 리턴하는 statement를 expression이라 부른다.
- 파라미터 값이 놓일 자리에 조건연산자를 둘 수 있다.

```java
public static void main(String[] args) {


    int age = 20;

    test(age > 18 ? "성년" : "미성년");
  }

  static void test(String value) {
    System.out.println(value + " 입니다.");
  }

```

-----

## 증감연산자

## 전위(pre-fix), 후위(post-fix) 연산자

- 기존 변수의 값을 1씩 증가시키고 i변수값에 저장한다.
  - i = i + 1
- `i++`, `i--`
  - i = `i++` , `i--`
  - i는 기존 변수 값이 오고 i++ 은 기존 변수에 증가, 감소값을 다음 변수를 선언할때 적용된다.
- `++i`, `--i`
  - i = `++i`, `--i`;
  - 증가, 감소값을 i변수에 저장한다.

간단예제를 통해 알아보자

```java
후위 증감 연산자
int i = 2;

// 증감 연산자가 없다면,
// 기존 변수의 값을 1증가시키기 위해 다음과 같이 코딩해야 한다.
// i = i + 1;

// 증감 연산자를 사용하면 다음과 같이 간략하게 작성할 수 있다.
i++; // i => 3
// 현재 위치에 i 메모리에 들어 있는 값(2)을 꺼내 놓는다.
// 그런 다음에 i 메모리의 값을 1 증가시킨다.
// 결론:
// ==> i++ 문장은 컴파일러가 i = i + 1 문장으로 바꾼다.
// ==> 즉 i = i + 1 문장을 축약한 문법에 불과하다.

i++; // i => 4

System.out.println(i); // 4

System.out.println(i++); // 4
// 위의 코드는 컴파일 할 때 다음의 코드로 바뀐다.
//
// int temp = i; //<-- 임시 변수를 만들어 현재 i 값을 저장한다.
// i = i + 1;
// System.out.println(temp);

System.out.println(i); // 5
```

```java
전위 증감 연산자
int i = 2;

++i;
// i 메모리의 값을 먼저 증가시킨다.
// 그리고 i 메모리의 값을 그 자리에 놓는다.

++i;

System.out.println(i); // 4

System.out.println(++i); 
// i = i + 1
// System.out.println(5)

System.out.println(i); // 5
```