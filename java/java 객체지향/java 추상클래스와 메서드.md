# 추상클래스

추상클래스의 목적

- 추상 메서드가 있든 없든 상관없이 추상 클래스를 만들 수 있다.
- 서브 클래스에게 공통 필드나 메서드를 상속해주는 것이 목적이다.
- 직접 사용하지 않는다.
- 여러 클래스를 같은 타입으로 묶기 위함이다.
- 상속에서 generalization을 통해 수퍼 클래스를 정의하는 경우에 그 수퍼 클래스를 주로 추상 클래스로 만든다.

## 추상메소드

- 메서드 선언부에 abstract를 붙인다.
- 메서드 몸체(body)가 없다.
- 추상 클래스나 인터페이스에서만 선언할 수 있다.

추상 메서드의 용도

- 서브 클래스 마다 구현이 다를 수 있는 경우에 사용한다.
- 서브 클래스가 반드시 구현해야 하는 메서드가 있다면 추상 메서드로 선언하라!
- 추상 메서드를 상속 받은 서브 클래스는 반드시 추상 메서드를 구현해야 한다.
  
만약 구현하지 않으면 서브 클래스도 추상 클래스가 되어야 한다.

왜?

추상 메서드를 갖는 클래스는 오직 추상 클래스만이 가능하기 때문이다.

```java
abstract class A2 {

  public abstract void m1();

  // 추상 메서드는 구현할 수 없다.
  //  public abstract void m2() {} // 컴파일 오류!
}

// 일반 클래스(concrete class)
class A2Sub extends A2 {
  @Override
  public void m1() {
    // 서브 클래스에서 추상 메서드를 구현해야 한다.
  }
}

public abstract class Exam02 extends A2 {
  // 서브 클래스에서 추상 메서드를 구현하지 않는다면,
  // 추상 메서드인 채로 남아 있기 때문에
  // 추상 클래스가 되어야 한다.
}
```

## 추상 클래스 레퍼런스와 메서드 호출

추상 메서드는 구현하지 않은 메서드이기 때문에

일반 클래스(=구현 클래스; concrete class)는 추상 메서드를 가질 수 없다.

오직 추상 클래스만이 추상 메서드를 가질 수 있다.

왜?

- 일반 클래스는 인스턴스를 생성할 수 있다.
- 인스턴스로 메서드를 호출하기 때문에
  일반 클래스에 완전히 정의되지 않은 메서드가 있다면,
  호출할 때 오류가 발생할 것이다.
- 이런 문제를 발생시키지 않기 위해
  일반 클래스는 추상 메서드를 갖지 않게 하였다.

```java
abstract class A3 {
  public abstract void m1();
}

class A3Sub extends A3 {
  @Override // 이 애노테이션은 빼도 된다.
  public void m1() {
    System.out.println("A3Sub.m1() 호출됨!");
  }

  public void m2() {
    System.out.println("A3Sub.m2() 호출됨!");
  }
}

public class Exam03 {
  public static void main(String[] args) {
    A3 obj;

    // 추상 클래스의 인스턴스는 생성 불가!
    //    obj = new A3(); // Error!

    // 추상 메서드를 구현한 서브 클래스 만이 인스턴스 생성 가능!
    obj = new A3Sub();

    // 오버라이딩 규칙에 따라
    // - 레퍼런스가 실제 가리키는 객체의 클래스에서부터 메서드를 찾는다.
    obj.m1();

    // 참고!
    // - 레퍼런스가 실제 가리키는 객체가 A3Sub 라 하더라도
    //   레퍼런스 타입의 범위를 넘어서 메서드를 호출할 수는 없다.
    //    obj.m2(); // 컴파일 오류!

    // - 물론 실제 인스턴스 타입으로 형벼환 후에는 가능한다.
    ((A3Sub)obj).m2();
  }

  static void test(A3 obj) {
    obj.m1();
    
    // 엥? 
    // obj는 A3의 레퍼런스이다.
    // A3의 m1() 은 추상 메서드이다.
    // 그런데 어떻게 m1() 을 호출하는가?

    // 답변:
    // - A3는 추상 클래스이기 때문에 A3의 인스턴스는 생성할 수 없다.
    // - 따라서 obj 파라미터에 넘어오는 인스턴스(주소)는 
    //   A3의 인스턴스가 아니라 A3의 자식 클래스의 인스턴스일 것이다.
    // - 인스턴스를 만들었다는 의미는 A3의 자식 클래스로서 
    //   A3의 모든 추상 메서드를 구현했다는 의미다.
    // - 따라서 obj를 가지고 m1() 를 호출할 때는 
    //   실제 obj가 가리키는 인스턴스의 클래스에서 m1() 메서드를 찾아 호출한다.
    // - 다시 한 번 말하지만 인스턴스를 만들었다는 것은 
    //   일반 클래스라는 뜻이고,
    //   일반 클래스에는 추상 메서드가 없다.
    //   그러므로 A3를 상속 받은 일반 클래스는 반드시 m1() 메서드를 구현했다는 의미다.
    // 


  }

}
```